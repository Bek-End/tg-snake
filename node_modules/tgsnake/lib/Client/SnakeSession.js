"use strict";
// Tgsnake - Telegram MTProto framework developed based on gram.js.
// Copyright (C) 2022 Butthx <https://github.com/butthx>
//
// This file is part of Tgsnake
//
// Tgsnake is a free software : you can redistribute it and/or modify
//  it under the terms of the MIT License as published.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SnakeSession = void 0;
const Memory_1 = require("telegram/sessions/Memory");
const AuthKey_1 = require("telegram/crypto/AuthKey");
const big_integer_1 = __importDefault(require("big-integer"));
const fs_1 = __importDefault(require("fs"));
let ignore = ['session.json', 'cache.json'];
const CURRENT_VERSION = '1';
class SnakeSession extends Memory_1.MemorySession {
    constructor(sessionName, client) {
        super();
        this._sessionName = sessionName;
        this.client = client;
    }
    async load() {
        var _a;
        if (fs_1.default.existsSync(`${process.cwd()}/${this._sessionName}`)) {
            let dir = fs_1.default.readdirSync(`${process.cwd()}/${this._sessionName}`);
            if (dir.includes('session.json')) {
                let json = undefined;
                try {
                    json = JSON.parse(fs_1.default.readFileSync(`${process.cwd()}/${this._sessionName}/session.json`, 'utf8'));
                }
                catch (error) {
                    // if can't parse the session file, delete it.
                    fs_1.default.unlinkSync(`${process.cwd()}/${this._sessionName}/session.json`);
                    return;
                }
                if (!json) {
                    fs_1.default.unlinkSync(`${process.cwd()}/${this._sessionName}/session.json`);
                    return;
                }
                let authKey = json.authKey;
                if (authKey && typeof authKey === 'object') {
                    this._authKey = new AuthKey_1.AuthKey();
                    if ('data' in authKey) {
                        authKey = Buffer.from(authKey.data);
                    }
                    await this._authKey.setKey(authKey);
                }
                if (json === null || json === void 0 ? void 0 : json.dcId)
                    this._dcId = json === null || json === void 0 ? void 0 : json.dcId;
                if (json === null || json === void 0 ? void 0 : json.port)
                    this._port = json === null || json === void 0 ? void 0 : json.port;
                if (json === null || json === void 0 ? void 0 : json.serverAddress)
                    this._serverAddress = json === null || json === void 0 ? void 0 : json.serverAddress;
            }
            else {
                // importing from storeSession then remove it.
                if (dir.includes(`${this._sessionName}%3AauthKey`)) {
                    let authKey = JSON.parse(fs_1.default.readFileSync(`${process.cwd()}/${this._sessionName}/${this._sessionName}%3AauthKey`, 'utf8'));
                    if (authKey && typeof authKey === 'object') {
                        this._authKey = new AuthKey_1.AuthKey();
                        if ('data' in authKey) {
                            authKey = Buffer.from(authKey.data);
                        }
                        await this._authKey.setKey(authKey);
                    }
                }
                if (dir.includes(`${this._sessionName}%3AdcId`)) {
                    let dcId = fs_1.default.readFileSync(`${process.cwd()}/${this._sessionName}/${this._sessionName}%3AdcId`, 'utf8');
                    if (!isNaN(Number(dcId)))
                        this._dcId = Number(dcId);
                }
                if (dir.includes(`${this._sessionName}%3Aport`)) {
                    let port = fs_1.default.readFileSync(`${process.cwd()}/${this._sessionName}/${this._sessionName}%3Aport`, 'utf8');
                    if (!isNaN(Number(port)))
                        this._port = Number(port);
                }
                if (dir.includes(`${this._sessionName}%3AserverAddress`)) {
                    let serverAddress = fs_1.default.readFileSync(`${process.cwd()}/${this._sessionName}/${this._sessionName}%3AserverAddress`, 'utf8');
                    if (serverAddress)
                        this._serverAddress = String(serverAddress).replace(/\"|\'/g, '');
                }
                fs_1.default.writeFileSync(`${process.cwd()}/${this._sessionName}/session.json`, JSON.stringify({
                    authKey: (_a = this._authKey) === null || _a === void 0 ? void 0 : _a.getKey(),
                    dcId: this._dcId,
                    port: this._port,
                    serverAddress: this._serverAddress,
                }));
                for (let file of dir) {
                    if (!ignore.includes(file)) {
                        fs_1.default.unlinkSync(`${process.cwd()}/${this._sessionName}/${file}`);
                    }
                }
            }
        }
    }
    setDC(dcId, serverAddress, port) {
        super.setDC(dcId, serverAddress, port);
        const create = () => {
            var _a;
            let dir = fs_1.default.readdirSync(`${process.cwd()}/${this._sessionName}`);
            fs_1.default.writeFileSync(`${process.cwd()}/${this._sessionName}/session.json`, JSON.stringify({
                authKey: (_a = this._authKey) === null || _a === void 0 ? void 0 : _a.getKey(),
                dcId: dcId,
                port: port,
                serverAddress: serverAddress,
            }));
            for (let file of dir) {
                if (!ignore.includes(file)) {
                    fs_1.default.unlinkSync(`${process.cwd()}/${this._sessionName}/${file}`);
                }
            }
        };
        if (fs_1.default.existsSync(`${process.cwd()}/${this._sessionName}`)) {
            create();
        }
        else {
            fs_1.default.mkdirSync(`${process.cwd()}/${this._sessionName}`, {
                recursive: true,
            });
            create();
        }
    }
    get authKey() {
        return this._authKey;
    }
    set authKey(value) {
        this._authKey = value;
        const create = () => {
            let dir = fs_1.default.readdirSync(`${process.cwd()}/${this._sessionName}`);
            fs_1.default.writeFileSync(`${process.cwd()}/${this._sessionName}/session.json`, JSON.stringify({
                authKey: value === null || value === void 0 ? void 0 : value.getKey(),
                dcId: this._dcId,
                port: this._port,
                serverAddress: this._serverAddress,
            }));
            for (let file of dir) {
                if (!ignore.includes(file)) {
                    fs_1.default.unlinkSync(`${process.cwd()}/${this._sessionName}/${file}`);
                }
            }
        };
        if (fs_1.default.existsSync(`${process.cwd()}/${this._sessionName}`)) {
            create();
        }
        else {
            fs_1.default.mkdirSync(`${process.cwd()}/${this._sessionName}`, {
                recursive: true,
            });
            create();
        }
    }
    getEntityRowsById(id, exact = true) {
        let Id = big_integer_1.default.isInstance(id) ? BigInt(String(id)) : String(id);
        // get from cache
        let cache = this.client.entityCache.get(Id);
        if (!cache)
            return [];
        return [
            String(cache.id),
            String(cache.accessHash),
            cache.username ? cache.username : '',
            cache.phone ? cache.phone : '',
            cache.lastName ? cache.firstName + ' ' + cache.lastName : cache.firstName,
            new Date().getTime().toString(),
        ];
    }
    save() {
        if (!this.authKey || !this.serverAddress || !this.port) {
            return '';
        }
        const key = this.authKey.getKey();
        if (!key) {
            return '';
        }
        const dcBuffer = Buffer.from([this.dcId]);
        const addressBuffer = Buffer.from(this.serverAddress);
        const addressLengthBuffer = Buffer.alloc(2);
        addressLengthBuffer.writeInt16BE(addressBuffer.length, 0);
        const portBuffer = Buffer.alloc(2);
        portBuffer.writeInt16BE(this.port, 0);
        return (CURRENT_VERSION +
            Buffer.concat([dcBuffer, addressLengthBuffer, addressBuffer, portBuffer, key]).toString('base64'));
    }
}
exports.SnakeSession = SnakeSession;
