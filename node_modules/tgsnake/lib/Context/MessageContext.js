"use strict";
// Tgsnake - Telegram MTProto framework developed based on gram.js.
// Copyright (C) 2022 Butthx <https://github.com/butthx>
//
// This file is part of Tgsnake
//
// Tgsnake is a free software : you can redistribute it and/or modify
//  it under the terms of the MIT License as published.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageContext = void 0;
const Message_1 = require("../Utils/Message");
const CleanObject_1 = require("../Utils/CleanObject");
const util_1 = require("util");
const telegram_1 = require("telegram");
const Password_1 = require("telegram/Password");
const big_integer_1 = __importDefault(require("big-integer"));
const Medias = __importStar(require("../Utils/Medias"));
class MessageContext extends Message_1.Message {
    constructor() {
        super();
    }
    /** @hidden */
    [util_1.inspect.custom]() {
        return (0, CleanObject_1.betterConsoleLog)(this);
    }
    /** @hidden */
    toJSON() {
        let obj = (0, CleanObject_1.betterConsoleLog)(this);
        for (let [key, value] of Object.entries(obj)) {
            if (typeof value == 'bigint')
                obj[key] = String(value);
        }
        return obj;
    }
    async reply(text, more) {
        if (this.id && this.chat.id) {
            let client = this.SnakeClient;
            return await client.telegram.sendMessage(this.chat.id, text, Object.assign({ replyToMsgId: this.id }, more));
        }
    }
    async replyWithHTML(text, more) {
        return await this.reply(text, Object.assign({ parseMode: 'html' }, more));
    }
    async replyWithMarkdown(text, more) {
        return await this.reply(text, Object.assign({ parseMode: 'markdown' }, more));
    }
    async delete() {
        let client = this.SnakeClient;
        return await client.telegram.deleteMessage(this.chat.id, this.id);
    }
    async forward(chatId, more) {
        let client = this.SnakeClient;
        return await client.telegram.forwardMessage(chatId, this.chat.id, this.id, more);
    }
    async pin(more) {
        let client = this.SnakeClient;
        return await client.telegram.pinMessage(this.chat.id, this.id, more);
    }
    async unpin() {
        let client = this.SnakeClient;
        return await client.telegram.unpinMessage(this.chat.id, this.id);
    }
    async link() {
        let client = this.SnakeClient;
        return await client.telegram.exportMessageLink(this.chat.id, this.id);
    }
    async click({ row, col, text, filter, callbackData, sharePhone, shareGeo, password, }) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (!this.replyMarkup)
            throw new Error("couldn't find any replyMarkup");
        const buildPeer = () => {
            if (this.chat.id === this.SnakeClient.aboutMe.id) {
                return new telegram_1.Api.InputPeerSelf();
            }
            if (this.chat.type === 'chat') {
                return new telegram_1.Api.InputPeerChat({
                    chatId: (0, big_integer_1.default)(String(this.chat.id)),
                });
            }
            if (this.chat.type === 'channel') {
                return new telegram_1.Api.InputPeerChannel({
                    channelId: (0, big_integer_1.default)(String(this.chat.id)),
                    accessHash: (0, big_integer_1.default)(String(this.chat.accessHash)),
                });
            }
            if (this.chat.type === 'supergroup') {
                return new telegram_1.Api.InputPeerChannel({
                    channelId: (0, big_integer_1.default)(String(this.chat.id)),
                    accessHash: (0, big_integer_1.default)(String(this.chat.accessHash)),
                });
            }
            if (this.chat.type === 'user') {
                return new telegram_1.Api.InputPeerUser({
                    userId: (0, big_integer_1.default)(String(this.chat.id)),
                    accessHash: (0, big_integer_1.default)(String(this.chat.accessHash)),
                });
            }
            return new telegram_1.Api.InputPeerEmpty();
        };
        const buildPeerBot = () => {
            if (this.from.bot) {
                if (this.from.id === this.SnakeClient.aboutMe.id) {
                    return new telegram_1.Api.InputPeerSelf();
                }
                return new telegram_1.Api.InputPeerUser({
                    userId: (0, big_integer_1.default)(String(this.from.id)),
                    accessHash: (0, big_integer_1.default)(String(this.from.accessHash)),
                });
            }
        };
        const makeFilter = async (callback) => {
            var _a, _b, _c, _d, _e, _f;
            //@ts-ignore
            if ((_a = this.replyMarkup) === null || _a === void 0 ? void 0 : _a.inlineKeyboard) {
                //@ts-ignore
                for (let r in (_b = this.replyMarkup) === null || _b === void 0 ? void 0 : _b.inlineKeyboard) {
                    //@ts-ignore
                    let rr = (_c = this.replyMarkup) === null || _c === void 0 ? void 0 : _c.inlineKeyboard[r];
                    for (let c in rr) {
                        if (await callback(rr[c], Number(r), Number(c))) {
                            row = Number(r);
                            col = Number(c);
                            return true;
                        }
                    }
                    return false;
                }
            }
            //@ts-ignore
            if ((_d = this.replyMarkup) === null || _d === void 0 ? void 0 : _d.keyboard) {
                //@ts-ignore
                for (let r in (_e = this.replyMarkup) === null || _e === void 0 ? void 0 : _e.keyboard) {
                    //@ts-ignore
                    let rr = (_f = this.replyMarkup) === null || _f === void 0 ? void 0 : _f.keyboard[r];
                    for (let c in rr) {
                        if (await callback(rr[c], Number(r), Number(c))) {
                            row = Number(r);
                            col = Number(c);
                            return true;
                        }
                    }
                    return false;
                }
            }
            return false;
        };
        if (text) {
            let isTrue = await makeFilter(async (btn, r, c) => {
                let t = typeof btn === 'string' ? btn : btn.text;
                if (typeof text === 'string')
                    return text === t;
                if (typeof text === 'function')
                    return text(t, Number(r), Number(c));
                return false;
            });
            if (!isTrue)
                return;
        }
        if (filter) {
            let isTrue = await makeFilter(async (btn, r, c) => {
                if (typeof filter === 'function')
                    return filter(btn, Number(r), Number(c));
                return false;
            });
            if (!isTrue)
                return;
        }
        if (callbackData) {
            let isTrue = await makeFilter(async (btn, r, c) => {
                //@ts-ignore
                let cb = typeof btn !== 'string' && btn.callbackData ? btn.callbackData : '';
                return cb === callbackData;
            });
            if (!isTrue)
                return;
        }
        if (row !== undefined || col !== undefined) {
            //@ts-ignore
            if ((_a = this.replyMarkup) === null || _a === void 0 ? void 0 : _a.inlineKeyboard) {
                //@ts-ignore
                let keyboard = (_b = this.replyMarkup) === null || _b === void 0 ? void 0 : _b.inlineKeyboard[row !== null && row !== void 0 ? row : 0][col !== null && col !== void 0 ? col : 0];
                if (keyboard && keyboard.url) {
                    if (String(keyboard.url).startsWith('tg://user?id=')) {
                        return await this.telegram.getEntity(BigInt(String(keyboard.url).replace('tg://user?id=', '')));
                    }
                    return keyboard.url;
                }
                if (keyboard && keyboard.callbackData) {
                    let encryptedPassword;
                    if (password !== undefined) {
                        let pwd = await this.SnakeClient.client.invoke(new telegram_1.Api.account.GetPassword());
                        encryptedPassword = await (0, Password_1.computeCheck)(pwd, password);
                    }
                    let request = new telegram_1.Api.messages.GetBotCallbackAnswer({
                        peer: buildPeer(),
                        msgId: this.id,
                        //@ts-ignore
                        data: Buffer.from(keyboard.callbackData),
                        password: encryptedPassword,
                    });
                    return await this.SnakeClient.client.invoke(request);
                }
                if (keyboard && keyboard.callbackGame) {
                    let request = new telegram_1.Api.messages.GetBotCallbackAnswer({
                        peer: buildPeer(),
                        msgId: this.id,
                        game: true,
                    });
                    return await this.SnakeClient.client.invoke(request);
                }
                if (keyboard && keyboard.switchInlineQuery) {
                    let request = new telegram_1.Api.messages.StartBot({
                        bot: buildPeerBot(),
                        peer: buildPeer(),
                        startParam: keyboard.switchInlineQuery,
                    });
                    return await this.SnakeClient.client.invoke(request);
                }
                if (keyboard && keyboard.switchInlineQueryCurrentChat) {
                    let request = new telegram_1.Api.messages.StartBot({
                        bot: buildPeerBot(),
                        peer: buildPeer(),
                        startParam: keyboard.switchInlineQueryCurrentChat,
                    });
                    return await this.SnakeClient.client.invoke(request);
                }
            }
            //@ts-ignore
            if ((_c = this.replyMarkup) === null || _c === void 0 ? void 0 : _c.keyboard) {
                //@ts-ignore
                let keyboard = (_d = this.replyMarkup) === null || _d === void 0 ? void 0 : _d.keyboard[row !== null && row !== void 0 ? row : 0][col !== null && col !== void 0 ? col : 0];
                if (keyboard && typeof keyboard !== 'string') {
                    if (keyboard.requestContact) {
                        if (sharePhone === true ||
                            typeof sharePhone === 'string' ||
                            sharePhone instanceof Medias.MediaContact) {
                            if (sharePhone instanceof Medias.MediaContact)
                                return this.telegram.sendContact(this.chat.id, sharePhone, {
                                    replyToMsgId: this.id,
                                });
                            return this.telegram.sendContact(this.chat.id, {
                                phoneNumber: (_e = (sharePhone === true ? this.SnakeClient.aboutMe.phone : sharePhone)) !== null && _e !== void 0 ? _e : '',
                                firstName: (_f = this.SnakeClient.aboutMe.firstName) !== null && _f !== void 0 ? _f : 'unknown',
                                lastName: (_g = this.SnakeClient.aboutMe.lastName) !== null && _g !== void 0 ? _g : '',
                                vcard: '',
                            }, {
                                replyToMsgId: this.id,
                            });
                        }
                    }
                    if (keyboard.requestLocation) {
                        if (shareGeo) {
                            return this.telegram.sendLocation(this.chat.id, shareGeo, {
                                replyToMsgId: this.id,
                            });
                        }
                    }
                }
            }
        }
        return;
    }
}
exports.MessageContext = MessageContext;
