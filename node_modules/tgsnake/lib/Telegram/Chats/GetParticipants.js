"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetParticipants = void 0;
const telegram_1 = require("telegram");
const ChatParticipants_1 = require("../../Utils/ChatParticipants");
const Error_1 = __importDefault(require("../../Context/Error"));
const big_integer_1 = __importDefault(require("big-integer"));
/**
 * Getting list from all participants in channel or chats.
 * @param snakeClient - Client
 * @param {number|string|bigint} chatId - Chat or channels id to getting the list of members.
 * @param {Object} more - more parameters to use.
 * ```ts
 * bot.command("getChatMembers",async (ctx) => {
 *     let results = await ctx.telegram.getParticipants(ctx.chat.id) // getChatMembers and getParticipants is same methods.
 *     console.log(results)
 * })
 * ```
 */
async function GetParticipants(snakeClient, chatId, more) {
    try {
        snakeClient.log.debug('Running telegram.getParticipants');
        if (typeof chatId === 'number')
            snakeClient.log.warning('Type of chatId is number, please switch to BigInt or String for security Ids 64 bit int.');
        let options = Object.assign({
            offset: 0,
            limit: 200,
            query: '',
            filter: 'all',
        }, more || {});
        let chat = await snakeClient.telegram.getEntity(chatId, true);
        if (chat.type == 'user') {
            throw new Error('Typeof chatId must be channel or chat, not a user.');
        }
        if (chat.type == 'chat') {
            let r = await snakeClient.client.invoke(new telegram_1.Api.messages.GetFullChat({
                chatId: (0, big_integer_1.default)(String(chat.id * BigInt(-1))),
            }));
            let cf = r.fullChat;
            let part = cf.participants;
            snakeClient.log.debug('Creating results telegram.getParticipants');
            let participant = new ChatParticipants_1.ChatParticipants();
            await participant.init(part, snakeClient);
            return participant;
        }
        if (chat.type == 'channel' || chat.type == 'supergroup') {
            let filter = new telegram_1.Api.ChannelParticipantsSearch({
                q: options.query,
            });
            switch (options.filter) {
                case 'kicked':
                    filter = new telegram_1.Api.ChannelParticipantsKicked({ q: options.query });
                    break;
                case 'restricted':
                    filter = new telegram_1.Api.ChannelParticipantsBanned({ q: options.query });
                    break;
                case 'bots':
                    filter = new telegram_1.Api.ChannelParticipantsBots();
                    break;
                case 'recents':
                    filter = new telegram_1.Api.ChannelParticipantsRecent();
                    break;
                case 'administrators':
                    filter = new telegram_1.Api.ChannelParticipantsAdmins();
                    break;
                default:
            }
            let r = (await snakeClient.client.invoke(new telegram_1.Api.channels.GetParticipants({
                channel: (0, big_integer_1.default)(chat.id),
                filter: filter,
                offset: options.offset,
                limit: options.limit,
                hash: (0, big_integer_1.default)(0),
            })));
            snakeClient.log.debug('Creating results telegram.getParticipants');
            let participant = new ChatParticipants_1.ChatParticipants();
            //@ts-ignore
            await participant.init(r, snakeClient);
            return participant;
        }
    }
    catch (error) {
        snakeClient.log.error('Failed to running telegram.getParticipants');
        throw new Error_1.default(error.message, 'telegram.getParticipants', `${chatId},${JSON.stringify(more)}`);
    }
}
exports.GetParticipants = GetParticipants;
