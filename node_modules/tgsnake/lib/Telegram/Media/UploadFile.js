"use strict";
// Tgsnake - Telegram MTProto framework developed based on gram.js.
// Copyright (C) 2022 Butthx <https://github.com/butthx>
//
// This file is part of Tgsnake
//
// Tgsnake is a free software : you can redistribute it and/or modify
//  it under the terms of the MIT License as published.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UploadFile = exports.inRange = void 0;
const uploads_1 = require("telegram/client/uploads");
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const axios_1 = __importDefault(require("axios"));
const Error_1 = __importDefault(require("../../Context/Error"));
const file_type_1 = require("file-type");
function inRange(x, min, max) {
    return (x - min) * (x - max) <= 0;
}
exports.inRange = inRange;
async function UploadFile(snakeClient, file, more) {
    try {
        snakeClient.log.debug('Running telegram.uploadFile');
        if ((more === null || more === void 0 ? void 0 : more.workers) !== undefined) {
            if (!inRange(more === null || more === void 0 ? void 0 : more.workers, 1, 16)) {
                snakeClient.log.warning(`Workers (${more.workers}) out of range (1 <= workers <= 16). Chances are this will make tgsnake unstable.`);
            }
        }
        if (Buffer.isBuffer(file)) {
            let fileInfo = await (0, file_type_1.fromBuffer)(file);
            //if (fileInfo) {
            let file_name = (more === null || more === void 0 ? void 0 : more.fileName) || `${Date.now() / 1000}.${fileInfo === null || fileInfo === void 0 ? void 0 : fileInfo.ext}`;
            let toUpload = new uploads_1.CustomFile(file_name, Buffer.byteLength(file), '', file);
            return snakeClient.client.uploadFile({
                file: toUpload,
                workers: (more === null || more === void 0 ? void 0 : more.workers) || 1,
                onProgress: more === null || more === void 0 ? void 0 : more.onProgress,
            });
            //}
        }
        else {
            let basename = path_1.default.basename(file);
            if (/^http/i.exec(file)) {
                let res = await axios_1.default.get(file, {
                    responseType: 'arraybuffer',
                });
                let data = res.data;
                let basebuffer = Buffer.from(data, 'utf-8');
                let file_name = (more === null || more === void 0 ? void 0 : more.fileName) || basename;
                let match = /\.([0-9a-z]+)(?=[?#])|(\.)(?:[\w]+)$/gim.exec(file_name);
                if (!match) {
                    let fileInfo = await (0, file_type_1.fromBuffer)(basebuffer);
                    if (fileInfo) {
                        file_name = `${file_name}.${fileInfo.ext}`;
                    }
                }
                let toUpload = new uploads_1.CustomFile(file_name, Buffer.byteLength(basebuffer), '', basebuffer);
                return await snakeClient.client.uploadFile({
                    file: toUpload,
                    workers: (more === null || more === void 0 ? void 0 : more.workers) || 1,
                    onProgress: more === null || more === void 0 ? void 0 : more.onProgress,
                });
            }
            if (/^(\/|\.\.?\/|~\/)/i.exec(file)) {
                let file_name = (more === null || more === void 0 ? void 0 : more.fileName) || basename;
                let match = /\.([0-9a-z]+)(?=[?#])|(\.)(?:[\w]+)$/gim.exec(file_name);
                if (!match) {
                    let fileInfo = await (0, file_type_1.fromFile)(file);
                    if (fileInfo) {
                        file_name = `${file_name}.${fileInfo.ext}`;
                    }
                }
                let toUpload = new uploads_1.CustomFile(file_name, fs_1.default.statSync(file).size, file);
                return await snakeClient.client.uploadFile({
                    file: toUpload,
                    workers: (more === null || more === void 0 ? void 0 : more.workers) || 1,
                    onProgress: more === null || more === void 0 ? void 0 : more.onProgress,
                });
            }
        }
    }
    catch (error) {
        snakeClient.log.error('Failed to running telegram.uploadFile');
        throw new Error_1.default(error.message, 'telegram.uploadFile', `${Buffer.isBuffer(file) ? `<Buffer ${file.toString('hex')}>` : file}${more ? ',' + JSON.stringify(more) : ''}`);
    }
}
exports.UploadFile = UploadFile;
