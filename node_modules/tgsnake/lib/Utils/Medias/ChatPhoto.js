"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MediaChatPhoto = void 0;
// Tgsnake - Telegram MTProto framework developed based on gram.js.
// Copyright (C) 2022 Butthx <https://guthub.com/butthx>
//
// This file is part of Tgsnake
//
// Tgsnake is a free software : you can redistribute it and/or modify
//  it under the terms of the MIT License as published.
const telegram_1 = require("telegram");
const Media_1 = require("./Media");
const tg_file_id_1 = require("tg-file-id");
const big_integer_1 = __importDefault(require("big-integer"));
const CleanObject_1 = require("../CleanObject");
const Error_1 = __importDefault(require("../../Context/Error"));
class MediaChatPhoto extends Media_1.Media {
    constructor() {
        super();
        this['_'] = 'chatPhoto';
    }
    async encode(chatPhoto, dialogId, dialogAccessHash, snakeClient) {
        snakeClient.log.debug('Creating MediaChatPhoto');
        this.snakeClient = snakeClient;
        this._dialogId = dialogId;
        this._dialogAccessHash = dialogAccessHash;
        this.isBig = true;
        this.dcId = chatPhoto.dcId;
        this._id = BigInt(String(chatPhoto.photoId));
        let file = new tg_file_id_1.FileId();
        file.fileType = 'profile_photo';
        file.typeId = 1;
        file.version = 4;
        file.subVersion = 30;
        file.dcId = this.dcId;
        file.id = this._id;
        file.accessHash = BigInt(0);
        file.photoSizeSource = 'dialogPhoto';
        file.dialogId = dialogId;
        file.isSmallDialogPhoto = false;
        file.photoSizeSourceId = 3;
        file.dialogAccessHash = dialogAccessHash;
        file.volumeId = BigInt(1);
        this.fileId = await file.toFileId();
        this.uniqueFileId = await file.toFileUniqId();
        await (0, CleanObject_1.Cleaning)(this);
        return this;
    }
    async download(fileId, params) {
        this.snakeClient.log.debug('Downloading chat photo');
        const { client, log } = this.snakeClient;
        const file = fileId !== null && fileId !== void 0 ? fileId : this.fileId;
        const getInputPeer = (dialogId, dialogAccessHash) => {
            if (String(dialogId).startsWith('-100')) {
                return new telegram_1.Api.InputPeerChannel({
                    channelId: (0, big_integer_1.default)(String(dialogId)),
                    accessHash: (0, big_integer_1.default)(String(dialogAccessHash)),
                });
            }
            if (String(dialogId).startsWith('-')) {
                return new telegram_1.Api.InputPeerChat({
                    chatId: (0, big_integer_1.default)(String(dialogId)),
                });
            }
            return new telegram_1.Api.InputPeerUser({
                userId: (0, big_integer_1.default)(String(dialogId)),
                accessHash: (0, big_integer_1.default)(String(dialogAccessHash)),
            });
        };
        if (!file) {
            this.snakeClient.log.error('Failed to download chat photo cause: FileId not found!');
            throw new Error_1.default('FileId not found!', 'ChatPhoto.download', String(file));
        }
        if (file !== this.fileId) {
            let dFile = this.decode(file);
            if (dFile.typeId !== 1) {
                this.snakeClient.log.error('Failed to download chat photo cause: Miss match file type!');
                throw new Error_1.default('Miss match file type!', 'ChatPhoto.download', String(file));
            }
            let dParams = Object.assign({
                dcId: dFile.dcId,
                progressCallback: (progress) => {
                    return log.debug(`Downloading chat photo [${Math.round(progress)}]`);
                },
            }, params !== null && params !== void 0 ? params : {});
            if (dParams.fileSize && typeof dParams.fileSize == 'bigint') {
                // @ts-ignore
                dParams.fileSize = (0, big_integer_1.default)(String(dParams.fileSize));
            }
            return client.downloadFile(new telegram_1.Api.InputPeerPhotoFileLocation({
                big: dFile.photoSize == 'big',
                peer: getInputPeer(BigInt(String(dFile.dialogId)), BigInt(String(dFile.dialogAccessHash))),
                photoId: (0, big_integer_1.default)(String(dFile.id)),
            }), 
            // @ts-ignore
            dParams);
        }
        let dParams = Object.assign({
            dcId: this.dcId,
            progressCallback: (progress) => {
                return log.debug(`Downloading chat photo [${Math.round(progress)}]`);
            },
        }, params !== null && params !== void 0 ? params : {});
        if (dParams.fileSize && typeof dParams.fileSize == 'bigint') {
            // @ts-ignore
            dParams.fileSize = (0, big_integer_1.default)(String(dParams.fileSize));
        }
        return client.downloadFile(new telegram_1.Api.InputPeerPhotoFileLocation({
            big: this.isBig,
            peer: getInputPeer(this._dialogId, this._dialogAccessHash),
            photoId: (0, big_integer_1.default)(String(this._id)),
        }), 
        // @ts-ignore
        dParams);
    }
}
exports.MediaChatPhoto = MediaChatPhoto;
