"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MediaPhoto = void 0;
// Tgsnake - Telegram MTProto framework developed based on gram.js.
// Copyright (C) 2022 Butthx <https://guthub.com/butthx>
//
// This file is part of Tgsnake
//
// Tgsnake is a free software : you can redistribute it and/or modify
//  it under the terms of the MIT License as published.
const telegram_1 = require("telegram");
const Media_1 = require("./Media");
const tg_file_id_1 = require("tg-file-id");
const big_integer_1 = __importDefault(require("big-integer"));
const CleanObject_1 = require("../CleanObject");
const Error_1 = __importDefault(require("../../Context/Error"));
class MediaPhoto extends Media_1.Media {
    constructor() {
        super();
        this['_'] = 'photo';
    }
    async encode(media, snakeClient) {
        snakeClient.log.debug('Creating MediaPhoto');
        this.snakeClient = snakeClient;
        if (media instanceof telegram_1.Api.PhotoEmpty)
            return this;
        const create = async (photo) => {
            var _a;
            this._id = BigInt(String(photo.id));
            this._accessHash = BigInt(String(photo.accessHash));
            this._fileReference = photo.fileReference.toString('hex');
            this.dcId = photo.dcId;
            this.hasStickers = (_a = photo.hasStickers) !== null && _a !== void 0 ? _a : false;
            if (photo.sizes) {
                for (let i = 0; i < photo.sizes.length; i++) {
                    if (photo.sizes[i] instanceof telegram_1.Api.PhotoSizeProgressive) {
                        let size = photo.sizes[i];
                        this.size = BigInt(Math.max(...size.sizes));
                        this.width = size.w;
                        this.height = size.h;
                        break;
                    }
                }
            }
            const file = new tg_file_id_1.FileId();
            file.id = BigInt(String(photo.id));
            file.accessHash = BigInt(String(photo.accessHash));
            file.version = 4;
            file.subVersion = 30;
            file.volumeId = BigInt(1);
            file.localId = 1;
            file.fileReference = photo.fileReference.toString('hex');
            file.fileType = 'photo';
            file.typeId = 2;
            file.thumbTypeId = 1;
            (file.thumbType = 'THUMBNAIL'),
                (file.photoSizeSource = 'thumbnail'),
                (file.photoSizeSourceId = 1);
            file.dcId = photo.dcId;
            this.fileId = await file.toFileId();
            this.uniqueFileId = await file.toFileUniqId();
        };
        if (media instanceof telegram_1.Api.Photo) {
            await create(media);
        }
        if (media instanceof telegram_1.Api.MessageMediaPhoto) {
            media;
            if (media.photo instanceof telegram_1.Api.Photo) {
                await create(media.photo);
            }
        }
        await (0, CleanObject_1.Cleaning)(this);
        return this;
    }
    async download(fileId, params) {
        this.snakeClient.log.debug('Downloading photo');
        const { client, log } = this.snakeClient;
        const file = fileId !== null && fileId !== void 0 ? fileId : this.fileId;
        if (!file) {
            this.snakeClient.log.error('Failed to download photo cause: FileId not found!');
            throw new Error_1.default('FileId not found!', 'Photo.download', String(file));
        }
        if (file !== this.fileId) {
            let dFile = this.decode(file);
            if (dFile.typeId !== 2) {
                this.snakeClient.log.error('Failed to download photo cause: Miss match file type!');
                throw new Error_1.default('Miss match file type!', 'Photo.download', String(file));
            }
            let dParams = Object.assign({
                dcId: dFile.dcId,
                progressCallback: (progress) => {
                    return log.debug(`Downloading photo [${Math.round(progress)}]`);
                },
            }, params !== null && params !== void 0 ? params : {});
            if (dParams.fileSize && typeof dParams.fileSize == 'bigint') {
                // @ts-ignore
                dParams.fileSize = (0, big_integer_1.default)(String(dParams.fileSize));
            }
            return client.downloadFile(new telegram_1.Api.InputPhotoFileLocation({
                id: (0, big_integer_1.default)(String(dFile.id)),
                accessHash: (0, big_integer_1.default)(String(dFile.access_hash)),
                fileReference: Buffer.from(dFile.fileReference, 'hex'),
                thumbSize: 'w',
            }), 
            // @ts-ignore
            dParams);
        }
        let dParams = Object.assign({
            dcId: this.dcId,
            fileSize: (0, big_integer_1.default)(this.size),
            progressCallback: (progress) => {
                return log.debug(`Downloading photo [${Math.round(progress)}]`);
            },
        }, params !== null && params !== void 0 ? params : {});
        if (dParams.fileSize && typeof dParams.fileSize == 'bigint') {
            // @ts-ignore
            dParams.fileSize = (0, big_integer_1.default)(String(dParams.fileSize));
        }
        return client.downloadFile(new telegram_1.Api.InputPhotoFileLocation({
            id: (0, big_integer_1.default)(String(this._id)),
            accessHash: (0, big_integer_1.default)(String(this._accessHash)),
            fileReference: Buffer.from(this._fileReference, 'hex'),
            thumbSize: 'w',
        }), 
        // @ts-ignore
        dParams);
    }
}
exports.MediaPhoto = MediaPhoto;
