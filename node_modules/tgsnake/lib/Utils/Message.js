"use strict";
// Tgsnake - Telegram MTProto framework developed based on gram.js.
// Copyright (C) 2022 Butthx <https://guthub.com/butthx>
//
// This file is part of Tgsnake
//
// Tgsnake is a free software : you can redistribute it and/or modify
//  it under the terms of the MIT License as published.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Message = void 0;
const telegram_1 = require("telegram");
const RestrictionReason_1 = require("./RestrictionReason");
const MessageAction_1 = require("./MessageAction");
const Chat_1 = require("./Chat");
const From_1 = require("./From");
const parser_1 = __importDefault(require("@tgsnake/parser"));
const ForwardMessage_1 = require("./ForwardMessage");
const Medias_1 = require("./Medias");
const ReplyMarkup_1 = require("./ReplyMarkup");
const ToBigInt_1 = require("./ToBigInt");
const CleanObject_1 = require("./CleanObject");
const Reactions_1 = require("./Reactions");
const parser = new parser_1.default(telegram_1.Api);
class Message {
    constructor() { }
    async init(message, SnakeClient) {
        SnakeClient.log.debug(`Creating Message`);
        this._SnakeClient = SnakeClient;
        if (message instanceof telegram_1.Api.Message) {
            return await this.parseMessage(message);
        }
        if (message instanceof telegram_1.Api.MessageService) {
            return await this.parseMessageService(message);
        }
    }
    // only parse Message Service
    /** @hidden */
    async parseMessageService(message) {
        this.out = message.out;
        this.mentioned = message.mentioned;
        this.mediaUnread = message.mediaUnread;
        this.silent = message.silent;
        this.legacy = message.legacy;
        this.id = message.id;
        this.date = message.date;
        this.post = message.post;
        //@ts-ignore
        this.noforward = message.noforwards;
        let messageAction = new MessageAction_1.MessageAction();
        await messageAction.init(message.action, this.SnakeClient);
        this.action = messageAction;
        this.ttlPeriod = message.ttlPeriod;
        if (message.fromId) {
            let from = new From_1.From();
            if (message.out) {
                await from.init(this.SnakeClient.aboutMe.id, this.SnakeClient);
            }
            else if (message.fromId instanceof telegram_1.Api.PeerChannel) {
                this.isAutomaticForward = false;
                this.senderChat = new Chat_1.Chat();
                await from.init('@Channel_Bot', this.SnakeClient);
                await this.senderChat.init(message.fromId, this.SnakeClient);
                if (message.fwdFrom) {
                    if (message.fwdFrom.savedFromPeer) {
                        this.isAutomaticForward = true;
                    }
                }
            }
            else if (message.fromId instanceof telegram_1.Api.PeerChat) {
                await from.init('@GroupAnonymousBot', this.SnakeClient);
            }
            else if (message.fromId instanceof telegram_1.Api.PeerUser) {
                await from.init(message.fromId, this.SnakeClient);
            }
            this.from = from;
        }
        else {
            if (message.peerId) {
                let from = new From_1.From();
                if (message.out) {
                    await from.init(this.SnakeClient.aboutMe.id, this.SnakeClient);
                }
                else if (message.peerId instanceof telegram_1.Api.PeerUser) {
                    await from.init(message.peerId, this.SnakeClient);
                }
                else if (message.peerId instanceof telegram_1.Api.PeerChannel ||
                    message.peerId instanceof telegram_1.Api.PeerChat) {
                    await from.init('@GroupAnonymousBot', this.SnakeClient);
                    if (!this.senderChat) {
                        this.senderChat = new Chat_1.Chat();
                        await this.senderChat.init(message.peerId, this.SnakeClient);
                    }
                }
                this.from = from;
            }
        }
        if (message.peerId) {
            let chat = new Chat_1.Chat();
            await chat.init(message.peerId, this.SnakeClient);
            this.chat = chat;
        }
        else {
            if (message.fromId) {
                let chat = new Chat_1.Chat();
                await chat.init(message.fromId, this.SnakeClient);
                this.chat = chat;
            }
        }
        if (message.replyTo) {
            this.SnakeClient.log.debug(`Creating replyToMessage`);
            let replyTo = await this.SnakeClient.telegram.getMessages(this.chat.id, [message.replyTo.replyToMsgId], false);
            this.replyToMessage = replyTo.messages[0];
        }
        await (0, CleanObject_1.Cleaning)(this);
        return this;
    }
    // only parse Message
    /** @hidden */
    async parseMessage(message) {
        var _a;
        this.out = message.out;
        this.mentioned = message.mentioned;
        this.mediaUnread = message.mediaUnread;
        this.silent = message.silent;
        this.legacy = message.legacy;
        this.id = message.id;
        this.date = message.date;
        this.post = message.post;
        this.fromScheduled = message.fromScheduled;
        this.editHide = message.editHide;
        this.pinned = message.pinned;
        //@ts-ignore
        this.noforward = message.noforwards;
        this.viaBotId =
            message.viaBotId !== null || message.viaBotId !== undefined
                ? BigInt((0, ToBigInt_1.toString)(message.viaBotId))
                : BigInt(0);
        this.text = message.message;
        this.views = message.views;
        this.forwards = message.forwards;
        this.postAuthor = message.postAuthor;
        this.mediaGroupId = BigInt(String((_a = message.groupedId) !== null && _a !== void 0 ? _a : 0));
        this.ttlPeriod = message.ttlPeriod;
        this.editDate = message.editDate;
        if (message.fromId) {
            let from = new From_1.From();
            if (message.out) {
                await from.init(this.SnakeClient.aboutMe.id, this.SnakeClient);
            }
            else if (message.fromId instanceof telegram_1.Api.PeerChannel) {
                this.isAutomaticForward = false;
                this.senderChat = new Chat_1.Chat();
                await from.init('@Channel_Bot', this.SnakeClient);
                await this.senderChat.init(message.fromId, this.SnakeClient);
                if (message.fwdFrom) {
                    if (message.fwdFrom.savedFromPeer) {
                        this.isAutomaticForward = true;
                    }
                }
            }
            else if (message.fromId instanceof telegram_1.Api.PeerChat) {
                await from.init('@GroupAnonymousBot', this.SnakeClient);
            }
            else if (message.fromId instanceof telegram_1.Api.PeerUser) {
                await from.init(message.fromId, this.SnakeClient);
            }
            this.from = from;
        }
        else {
            if (message.peerId) {
                let from = new From_1.From();
                if (message.out) {
                    await from.init(this.SnakeClient.aboutMe.id, this.SnakeClient);
                }
                else if (message.peerId instanceof telegram_1.Api.PeerUser) {
                    await from.init(message.peerId, this.SnakeClient);
                }
                else if (message.peerId instanceof telegram_1.Api.PeerChannel ||
                    message.peerId instanceof telegram_1.Api.PeerChat) {
                    await from.init('@GroupAnonymousBot', this.SnakeClient);
                    if (!this.senderChat) {
                        this.senderChat = new Chat_1.Chat();
                        await this.senderChat.init(message.peerId, this.SnakeClient);
                    }
                }
                this.from = from;
            }
        }
        if (message.peerId) {
            let chat = new Chat_1.Chat();
            await chat.init(message.peerId, this.SnakeClient);
            this.chat = chat;
        }
        else {
            if (message.fromId) {
                let chat = new Chat_1.Chat();
                await chat.init(message.fromId, this.SnakeClient);
                this.chat = chat;
            }
        }
        if (message.media) {
            this.media = await (0, Medias_1.GenerateMedia)(message.media, this._SnakeClient);
        }
        if (message.replyTo) {
            this.SnakeClient.log.debug(`Creating replyToMessage`);
            let replyTo = await this.SnakeClient.telegram.getMessages(this.chat.id, [message.replyTo.replyToMsgId], false);
            this.replyToMessage = replyTo.messages[0];
        }
        if (message.fwdFrom) {
            let forward = new ForwardMessage_1.ForwardMessage();
            await forward.init(message.fwdFrom, this.SnakeClient);
            this.fwdFrom = forward;
        }
        if (message.entities) {
            this.entities = parser.fromRaw(message.entities);
        }
        if (message.restrictionReason) {
            let temp = [];
            for (let i = 0; i < message.restrictionReason.length; i++) {
                temp.push(new RestrictionReason_1.RestrictionReason(message.restrictionReason[i]));
            }
            this.restrictionReason = temp;
        }
        // todo
        // change the  replies json.
        if (message.replyMarkup) {
            this.replyMarkup = await (0, ReplyMarkup_1.convertReplyMarkup)(message.replyMarkup, this.SnakeClient);
        }
        if (message.replies) {
            this.replies = message.replies;
        }
        if (message.reactions) {
            this.reactions = message.reactions.results.map((el) => new Reactions_1.Reactions(el));
        }
        await (0, CleanObject_1.Cleaning)(this);
        return this;
    }
    get SnakeClient() {
        return this._SnakeClient;
    }
    get snakeClient() {
        return this._SnakeClient;
    }
    set SnakeClient(client) {
        this._SnakeClient = client;
    }
    set snakeClient(client) {
        this._SnakeClient = client;
    }
    get telegram() {
        return this._SnakeClient.telegram;
    }
}
exports.Message = Message;
