"use strict";
// Tgsnake - Telegram MTProto framework developed based on gram.js.
// Copyright (C) 2022 Butthx <https://guthub.com/butthx>
//
// This file is part of Tgsnake
//
// Tgsnake is a free software : you can redistribute it and/or modify
//  it under the terms of the MIT License as published
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertReplyMarkup = exports.BuildReplyMarkup = void 0;
const telegram_1 = require("telegram");
const big_integer_1 = __importDefault(require("big-integer"));
const ToBigInt_1 = require("./ToBigInt");
async function BuildReplyMarkup(replyMarkup, snakeClient) {
    // inlineKeyboard
    if ('inlineKeyboard' in replyMarkup) {
        return await replyMarkupInlineKeyboard(replyMarkup, snakeClient);
    }
    // keyboard
    if ('keyboard' in replyMarkup) {
        return await replyMarkupKeyboard(replyMarkup);
    }
    // removeKeyboard
    if ('removeKeyboard' in replyMarkup) {
        return await replyMarkupRemoveKeyboard(replyMarkup);
    }
    // forceReply
    if ('forceReply' in replyMarkup) {
        return await replyMarkupForceReply(replyMarkup);
    }
}
exports.BuildReplyMarkup = BuildReplyMarkup;
async function replyMarkupInlineKeyboard(replyMarkup, snakeClient) {
    var _a, _b, _c, _d, _e;
    let rows = [];
    for (let row = 0; row < replyMarkup.inlineKeyboard.length; row++) {
        let tempCol = [];
        for (let col = 0; col < replyMarkup.inlineKeyboard[row].length; col++) {
            let btn = replyMarkup.inlineKeyboard[row][col];
            // button url
            if (btn.url) {
                if (String(btn.url).startsWith('tg://user?id=')) {
                    let [id, type, peer] = await (0, ToBigInt_1.toBigInt)(BigInt(String(btn.url).replace('tg://user?id=', '')), snakeClient);
                    if (type !== 'user')
                        continue;
                    tempCol.push(new telegram_1.Api.InputKeyboardButtonUserProfile({
                        text: String(btn.text),
                        //@ts-ignore
                        userId: new telegram_1.Api.InputUser({
                            //@ts-ignore
                            userId: peer.userId,
                            //@ts-ignore
                            accessHash: peer.accessHash,
                        }),
                    }));
                }
                else {
                    tempCol.push(new telegram_1.Api.KeyboardButtonUrl({
                        text: String(btn.text),
                        url: String(btn.url),
                    }));
                }
                continue;
            }
            // button login url
            if (btn.loginUrl) {
                tempCol.push(new telegram_1.Api.InputKeyboardButtonUrlAuth({
                    text: String(btn.text),
                    requestWriteAccess: ((_a = btn.loginUrl) === null || _a === void 0 ? void 0 : _a.requestWriteAccess) || true,
                    fwdText: ((_b = btn.loginUrl) === null || _b === void 0 ? void 0 : _b.forwardText) || String(btn.text),
                    url: String((_c = btn.loginUrl) === null || _c === void 0 ? void 0 : _c.url),
                    bot: new telegram_1.Api.InputUser({
                        userId: (0, big_integer_1.default)((_d = btn.loginUrl) === null || _d === void 0 ? void 0 : _d.bot.id),
                        accessHash: (0, big_integer_1.default)((_e = btn.loginUrl) === null || _e === void 0 ? void 0 : _e.bot.accessHash),
                    }),
                }));
                continue;
            }
            // button callbackData
            if (btn.callbackData) {
                tempCol.push(new telegram_1.Api.KeyboardButtonCallback({
                    text: String(btn.text),
                    requiresPassword: false,
                    data: Buffer.from(String(btn.callbackData)),
                }));
                continue;
            }
            // button switch inline query
            if (btn.switchInlineQuery) {
                tempCol.push(new telegram_1.Api.KeyboardButtonSwitchInline({
                    text: String(btn.text),
                    samePeer: false,
                    query: String(btn.switchInlineQuery),
                }));
                continue;
            }
            // button switch inline query current peer
            if (btn.switchInlineQueryCurrentChat) {
                tempCol.push(new telegram_1.Api.KeyboardButtonSwitchInline({
                    text: String(btn.text),
                    samePeer: true,
                    query: String(btn.switchInlineQueryCurrentChat),
                }));
                continue;
            }
            // button game
            if (btn.callbackGame) {
                tempCol.push(new telegram_1.Api.KeyboardButtonGame({
                    text: String(btn.text),
                }));
                continue;
            }
            // button buy
            if (btn.buy) {
                tempCol.push(new telegram_1.Api.KeyboardButtonBuy({
                    text: String(btn.text),
                }));
                continue;
            }
        }
        rows.push(new telegram_1.Api.KeyboardButtonRow({
            buttons: tempCol,
        }));
    }
    return new telegram_1.Api.ReplyInlineMarkup({
        rows: rows,
    });
}
function replyMarkupKeyboard(replyMarkup) {
    let rows = [];
    for (let row = 0; row < replyMarkup.keyboard.length; row++) {
        let tempCol = [];
        for (let col = 0; col < replyMarkup.keyboard[row].length; col++) {
            // if string[][]
            if (typeof replyMarkup.keyboard[row][col] == 'string') {
                tempCol.push(new telegram_1.Api.KeyboardButton({
                    text: String(replyMarkup.keyboard[row][col]),
                }));
                continue;
            }
            if (typeof replyMarkup.keyboard[row][col] !== 'string') {
                let btn = replyMarkup.keyboard[row][col];
                // keyboard requestContact
                if (btn.requestContact) {
                    tempCol.push(new telegram_1.Api.KeyboardButtonRequestPhone({
                        text: String(btn.text),
                    }));
                    continue;
                }
                //keyboard requestLocation
                if (btn.requestLocation) {
                    tempCol.push(new telegram_1.Api.KeyboardButtonRequestGeoLocation({
                        text: String(btn.text),
                    }));
                    continue;
                }
                //keyboard requestPoll
                if (btn.requestPoll) {
                    tempCol.push(new telegram_1.Api.KeyboardButtonRequestPoll({
                        text: String(btn.text),
                        quiz: Boolean(btn.requestPoll.toLowerCase() == 'quiz'),
                    }));
                    continue;
                }
                // keyboard text
                if (btn.text) {
                    if (!btn.requestPoll && !btn.requestLocation && !btn.requestContact) {
                        tempCol.push(new telegram_1.Api.KeyboardButton({
                            text: String(btn.text),
                        }));
                        continue;
                    }
                }
            }
        }
        rows.push(new telegram_1.Api.KeyboardButtonRow({
            buttons: tempCol,
        }));
    }
    return new telegram_1.Api.ReplyKeyboardMarkup({
        rows: rows,
        resize: replyMarkup.resizeKeyboard || undefined,
        singleUse: replyMarkup.oneTimeKeyboard || undefined,
        placeholder: replyMarkup.inputFieldPlaceholder || undefined,
        selective: replyMarkup.selective || undefined,
    });
}
function replyMarkupRemoveKeyboard(replyMarkup) {
    return new telegram_1.Api.ReplyKeyboardHide({
        selective: replyMarkup.selective || undefined,
    });
}
function replyMarkupForceReply(replyMarkup) {
    return new telegram_1.Api.ReplyKeyboardForceReply({
        singleUse: replyMarkup.singleUse || undefined,
        selective: replyMarkup.selective || undefined,
        placeholder: replyMarkup.inputFieldPlaceholder || undefined,
    });
}
async function convertReplyMarkup(replyMarkup, SnakeClient) {
    // force reply
    if (replyMarkup instanceof telegram_1.Api.ReplyKeyboardForceReply) {
        replyMarkup;
        let markup = {
            forceReply: true,
            selective: replyMarkup.selective || undefined,
            singleUse: replyMarkup.singleUse || undefined,
            inputFieldPlaceholder: replyMarkup.placeholder || undefined,
        };
        return markup;
    }
    // removeKeyboard
    if (replyMarkup instanceof telegram_1.Api.ReplyKeyboardHide) {
        replyMarkup;
        let markup = {
            removeKeyboard: true,
            selective: replyMarkup.selective || undefined,
        };
    }
    // KeyboardButton
    if (replyMarkup instanceof telegram_1.Api.ReplyKeyboardMarkup) {
        replyMarkup;
        let rows = [];
        for (let i = 0; i < replyMarkup.rows.length; i++) {
            let col = [];
            let btns = replyMarkup.rows[i];
            for (let j = 0; j < btns.buttons.length; j++) {
                let btn = btns.buttons[j];
                if (btn instanceof telegram_1.Api.KeyboardButton) {
                    btn;
                    let cc = {
                        text: btn.text,
                    };
                    col.push(cc);
                }
                if (btn instanceof telegram_1.Api.KeyboardButtonRequestPhone) {
                    btn;
                    let cc = {
                        text: btn.text,
                        requestContact: true,
                    };
                    col.push(cc);
                }
                if (btn instanceof telegram_1.Api.KeyboardButtonRequestGeoLocation) {
                    btn;
                    let cc = {
                        text: btn.text,
                        requestLocation: true,
                    };
                    col.push(cc);
                }
                if (btn instanceof telegram_1.Api.KeyboardButtonRequestPoll) {
                    btn;
                    let cc = {
                        text: btn.text,
                        requestPoll: btn.quiz ? 'quiz' : 'regular',
                    };
                    col.push(cc);
                }
            }
            rows.push(col);
        }
        let markup = {
            keyboard: rows,
            resizeKeyboard: replyMarkup.resize || undefined,
            oneTimeKeyboard: replyMarkup.singleUse || undefined,
            inputFieldPlaceholder: replyMarkup.placeholder || undefined,
            selective: replyMarkup.selective || undefined,
        };
        return markup;
    }
    // inlineKeyboardButton
    if (replyMarkup instanceof telegram_1.Api.ReplyInlineMarkup) {
        replyMarkup;
        let rows = [];
        for (let i = 0; i < replyMarkup.rows.length; i++) {
            let col = [];
            let btns = replyMarkup.rows[i];
            for (let j = 0; j < btns.buttons.length; j++) {
                let btn = btns.buttons[j];
                if (btn instanceof telegram_1.Api.KeyboardButtonUserProfile) {
                    btn;
                    let cc = {
                        text: btn.text,
                        url: `tg://user?id=${btn.userId}`,
                    };
                    col.push(cc);
                }
                if (btn instanceof telegram_1.Api.KeyboardButtonUrl) {
                    btn;
                    let cc = {
                        text: btn.text,
                        url: btn.url,
                    };
                    col.push(cc);
                }
                if (btn instanceof telegram_1.Api.KeyboardButtonUrlAuth) {
                    btn;
                    let me = await SnakeClient.telegram.getMe();
                    let ee = {
                        id: me.id,
                        accessHash: me.accessHash,
                    };
                    let dd = {
                        requestWriteAccess: true,
                        forwardText: btn.fwdText || String(btn.text),
                        url: String(btn.url),
                        bot: ee,
                    };
                    let cc = {
                        loginUrl: dd,
                        text: btn.text,
                    };
                    col.push(cc);
                }
                if (btn instanceof telegram_1.Api.KeyboardButtonCallback) {
                    btn;
                    let cc = {
                        text: btn.text,
                        callbackData: btn.data.toString('utf8'),
                    };
                    col.push(cc);
                }
                if (btn instanceof telegram_1.Api.KeyboardButtonSwitchInline) {
                    btn;
                    if (btn.samePeer) {
                        let cc = {
                            text: btn.text,
                            switchInlineQueryCurrentChat: btn.query,
                        };
                        col.push(cc);
                    }
                    else {
                        let cc = {
                            text: btn.text,
                            switchInlineQuery: btn.query,
                        };
                        col.push(cc);
                    }
                }
                if (btn instanceof telegram_1.Api.KeyboardButtonGame) {
                    btn;
                    let cc = {
                        text: btn.text,
                        callbackGame: btn.text,
                    };
                    col.push(cc);
                }
                if (btn instanceof telegram_1.Api.KeyboardButtonBuy) {
                    btn;
                    let cc = {
                        text: btn.text,
                        buy: btn.text,
                    };
                    col.push(cc);
                }
            }
            rows.push(col);
        }
        let markup = {
            inlineKeyboard: rows,
        };
        return markup;
    }
}
exports.convertReplyMarkup = convertReplyMarkup;
